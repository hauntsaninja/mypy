from typing import Generic, TypeVar, Callable, Any, Mapping, NamedTuple, Protocol, Self, TypedDict, overload
from collections.abc import Hashable

_T = TypeVar("_T")

class _SingleDispatchCallable(Generic[_T]):
    registry: Mapping[Any, Callable[..., _T]]
    def dispatch(self, cls: Any) -> Callable[..., _T]: ...
    # @fun.register(complex)
    # def _(arg, verbose=False): ...
    @overload
    def register(self, cls: type[Any], func: None = ...) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...
    # @fun.register
    # def _(arg: int, verbose=False):
    @overload
    def register(self, cls: Callable[..., _T], func: None = ...) -> Callable[..., _T]: ...
    # fun.register(int, lambda x: x)
    @overload
    def register(self, cls: type[Any], func: Callable[..., _T]) -> Callable[..., _T]: ...
    def _clear_cache(self) -> None: ...
    def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...

def singledispatch(func: Callable[..., _T]) -> _SingleDispatchCallable[_T]: ...

def total_ordering(cls: type[_T]) -> type[_T]: ...

class cached_property(Generic[_T]):
    func: Callable[[Any], _T]
    attrname: str | None
    def __init__(self, func: Callable[[Any], _T]) -> None: ...
    @overload
    def __get__(self, instance: None, owner: type[Any] | None = ...) -> cached_property[_T]: ...
    @overload
    def __get__(self, instance: object, owner: type[Any] | None = ...) -> _T: ...
    def __set_name__(self, owner: type[Any], name: str) -> None: ...
    def __class_getitem__(cls, item: Any) -> Any: ...

class partial(Generic[_T]):
    def __new__(cls, __func: Callable[..., _T], *args: Any, **kwargs: Any) -> Self: ...
    def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...

def wraps(wrapped: _T) -> partial[_T]: ...


class Hashable(Protocol):
    def __hash__(self) -> int: ...

class _CacheInfo(NamedTuple):
    hits: int
    misses: int
    maxsize: int | None
    currsize: int

class _CacheParameters(TypedDict):
    maxsize: int
    typed: bool

_T_co = TypeVar("_T_co", covariant=True)

class _lru_cache_wrapper(Generic[_T_co]):
    __wrapped__: Callable[..., _T_co]
    def __call__(self, *args: Hashable, **kwargs: Hashable) -> _T_co: ...
    def cache_info(self) -> _CacheInfo: ...
    def cache_clear(self) -> None: ...
    def cache_parameters(self) -> _CacheParameters: ...
    def __copy__(self) -> _lru_cache_wrapper[_T_co]: ...
    def __deepcopy__(self, memo: Any, /) -> _lru_cache_wrapper[_T_co]: ...

def cache(user_function: Callable[..., _T], /) -> _lru_cache_wrapper[_T]: ...

@overload
def lru_cache(maxsize: int | None = 128, typed: bool = False) -> Callable[[Callable[..., _T]], _lru_cache_wrapper[_T]]: ...
@overload
def lru_cache(maxsize: Callable[..., _T], typed: bool = False) -> _lru_cache_wrapper[_T]: ...
